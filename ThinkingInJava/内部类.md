# 内部类

## 创建内部类

+ 可以将一个类的定义放在另外一个类的定义内部，这就是内部类。
+ 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体指定这个对象的类型：外部类名称.内部类名称(如果在本类中创建则不需要)。

## 链接到外部类

+ 内部类拥有外围类的所有元素的访问权。

```java
    //使用.this和.new
```

## 内部类与向上转型

+ 可以用一个内部类实现一个接口，然后声明为私有的，再u在外部类提供一个方法返回内部类的实例，可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。

## 在方法和作用域内的内部类

+ 用if(b){内部类}的形式可以创建任意格式的内部类

### 方法内的内部类（局部内部类）

+ 方法外部不能访问内部类

### 定义在方法内部作用域的类

+ if（boolean）{内部类}

### 匿名内部类

+ 可以简化写成 return new Contents() {内部类}
+ 匿名内部类没有有名字的构造器（因为它根本没有名字），但通过实例初始化，就能达到为匿名内部类创建一个构造器的效果。如果传的参数不是在基类中使用，而是在内部类直接使用，则需要将参数直接声明成final
+ 使用匿名内部类来实现工厂模式。

### 嵌套内部类

+ 内部类声明为static，通常称为嵌套类
+ 普通的内部类隐式地保存了一个引用，指向创建它的外部类对象，然而在嵌套类里，要创建内部类的对象，并不需要其外部类的对象，不能从内部类的对象中访问非静态的外围类对象。
+ 普通内部类的字段和方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含内部类，但是内部类可以包含所有这些东西。

### 接口内部的类

+ 嵌套类可以作为接口的一部分。放到接口中的任何类都自动地是public和static的，甚至可以直接在接口里实现外围接口。
+ 如果要创建某些公共代码，可以使用接口的嵌套类（可以放main()方法测试用，执行 接口名$内部类.class）
+ 内部类无论嵌套多少层，其对外围类的成员都能直接访问，new 对象的时候需要一层层.下去，例如 MNA.A.B nanab = mnaa.new B();

### 使用内部类的好处

+ 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。内部类有效地实现了”多层继承“。内部类允许继承多个非接口类型（类或抽象类）

### 内部类的一些特性

+ 内部类可以有多个实例，每个实例都可以有自己的状态信息，并且与其外围类对象的信息相互独立。
+ 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
+ 创建内部类的对象的时刻并不依赖于外部类对象的创建。
+ 内部类并没有令人迷惑的 is-a 关系，它就是一个独立的实体。

### 闭包和回调

+ 闭包指的是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域
+ 可以看出内部类是面向对象的闭包，因为它不仅包含外围类的对象的信息，还自动拥有一个指向此外围类对象的引用。
+ 通过回调，对象能够携带一些信息，这些信息允许它稍后的某个时刻调用初始的对象。钩子回调(Callee2.this.increment())。

### 内部类和控制框架

### 内部类的继承

```java
    class A {
        class B{}
    }
    public class C extends A.B {
        C(A a) {
            a.supre();
        }
        public static void main(String[] args) {
            A a = new A();
            B b = new B(a);
        }
    }
```

### 内部类可以被覆盖吗

+ 覆盖并不会起什么作用，因为两个内部类是完全独立的实体，各自在自己的命名空间内。

### 局部内部类

+ 可以在代码块和方法内创建内部类。
+ 使用局部内部类和匿名内部类实现了这个功能，他们具有相同的行为和能力，那么为什么我们仍然使用局部内部类而不是匿名内部类呢，唯一的理由是，我们需要一个已命名的构造器，或者需要重构构造器，而匿名内部类只能用于实例初始化，所以使用局部内部类而不是匿名内部类的理由是，需要不止一个该内部类的对象。

