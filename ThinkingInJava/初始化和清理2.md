# 初始化和清理

## static的含义

+ 在static方法的内部不能调用非静态方法，但这不是完全不可能，如果你传递一个对象的引用到静态方法里（静态方法可以创建其自身的对象），然后通过这个引用（和this作用相同），你就可以调用非静态方法和访问非静态数据成员了。
+ 类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。
在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错：而类又是在什么时候加载的呢?由引导类加载器负责加载的核心类比如 String 类在 JVM 启动时（main 方法开始执行前）就会被加载，其它类在使用前（new 它对象或调用其静态方法访问静态域等等前）会被动态加载，要注意的是子类被加载前它的所有超类要根据由父到子的顺序被逐一加载。

## 清理：终结清理和垃圾回收

+ 对象可能不被垃圾回收，垃圾回收并不等于“析构”，垃圾回收只与内存有关。
+ finalize（）方法是因为在使用本地方法的情况下，用c或者c++分配了存储空间，然后需要在finalize（）方法中用本地访问调用c或者c++中的free（）方法释放内存，finalize()方法还可以用来验证终结条件（System.gc()用于强制进行终结动作），并且通常要假设基类的finalize（）也要做某些重要的事情，因此要使用super.finalize()来调用它。

## 垃圾回收器如何工作

+ **标记-清扫**，从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，然后给其标记，当全部标记工作完成后，没有标记的内存会被释放，由于不会发生复制动作，所以剩下的堆空间是不连续的。
+ **停止-复制** ，先暂停程序运行，然后将所有存活的对象从当前堆复制到另外一个堆，没有复制的全部是垃圾，由于需要重新修正引用和开辟另外一个堆，这种效率会很低下。
+ **自适应技术**java虚拟机会进行定期的完整的清理动作，大型对象不会进行复制（只是其代数会增加），内含小型对象的那些块则被复制并整理，java虚拟机会进行监视，如果垃圾回收器的效率很低的话，就切换到“标记-清扫”方式；同样，java虚拟机会跟踪“标记-清扫”的效果，要是堆空间出现很多碎片，就会切换成“停止-复制”方式，这就是自适应技术。
+ **即时编译器技术**一种策略是编译所有的代码，但是由于有些代码可能不会用，造成浪费开销。另外一种做法是”惰性评估“，只有在必要的时候才编译代码，新版jdk的java hotspot就采用的类似方法，代码每次执行的时候都会做一些优化，所以执行的次数越多，它的速度越快。

## java初始化顺序
+ java初始化顺序
![JAVA初始化顺序](https://images2015.cnblogs.com/blog/690102/201705/690102-20170523100400163-1438483040.png)
+ static代码块，与其他静态初始化动作一样，这段代码只执行一次，当首次生成这个类的一个对象时，或者首次访问属于那个类的静态成员时（即便从未生成那个类的对象）就会执行初始化。
+ 可变参数列表：你应该只在重载方法的一个版本上使用，或者压根不使用它。（可以在方法参数中添加一个非可变参数来解决问题，比如f（float i ,Integer...args））

## 枚举类型

+ 创建枚举类时，编译器会自动添加一些特性，比如toString方法，ordinal（）方法，用来表示某个特定的enum常量的声明顺序，以及static values（）方法，用来按照enum常量的声明顺序，产生由这些常量值构成的数组（可以用做foreach）。enum还可以用在switch语句里。
+ java访问内部类的方式//创建外部类Test对象Test a=new Test();
//使用外部类对象a来new一个person对象mm
Person mm=a.new Person();
System.out.println(mm.age=100);

## java解释器

+ java解释器的运行过程如下：首先，找出环境变量CLASSPATH，CLASSPATH包含一个或者多个目录，用作查找.class文件的根目录，从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，以从CLASSPATH根中产生一个路径名称，得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件（解释器还会去查找某些涉及JAVA解释器所在位置的标准目录。）
+ 包访问权限的类某个成员是static和public的话，则客户端程序员仍旧可以调用该static成员。
+ 要阻止别人创建某个类的对象，可以把构造器声明成private，然后在static成员内部创建。